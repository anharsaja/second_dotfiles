var de=Object.defineProperty;var te=c=>{throw TypeError(c)};var le=(c,e,t)=>e in c?de(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var l=(c,e,t)=>le(c,typeof e!="symbol"?e+"":e,t),ie=(c,e,t)=>e.has(c)||te("Cannot "+t);var i=(c,e,t)=>(ie(c,e,"read from private field"),t?t.call(c):e.get(c)),a=(c,e,t)=>e.has(c)?te("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(c):e.set(c,t),se=(c,e,t,s)=>(ie(c,e,"write to private field"),s?s.call(c,t):e.set(c,t),t);import{E as ue,O as f,D as _,P as he,L as ge,C as me,M as pe,y as we,A as be,S as fe,o as ye,j as ae,e as ne,z as ve,F as Se,q as Ie,G as Oe,h as Ae,p as re}from"./Scheduler-CV7gOmjW.js";import{l as r,c as h}from"./Logger-CenPrHM_.js";import"./MessageBridge-C2lz_3Ul.js";import"./index.esm-DBQD-6dI.js";import"./vendor/vue-D7guW3iV.js";import"./SandboxBridge-usUhTs-I.js";import"./vendor/aws-C9aIMT75.js";var V,A,$,D,W,q,F,L;class Le{constructor(){l(this,"clear",async(e,t)=>{const s=await i(this,V).call(this,e,t);for(let n=0;n<s.length;n++){const o=s[n];await chrome.browsingData.remove(o.options,o.dataToRemove)}return e});l(this,"clearFromSettings",async()=>{const e=await chrome.browsingData.settings();return chrome.browsingData.remove(e.options,e.dataToRemove)});a(this,V,async(e,t)=>{e=structuredClone(e);let s=e.browser.options,n=e.browser.dataToRemove;s.since=ue(e.extension.timeperiod),s=await i(this,A).call(this,s,e.extension.originMode);const o=[];if(e.extension.originMode===f.All)o.push({options:s,dataToRemove:n});else{let u=await i(this,$).call(this,n),v=await i(this,D).call(this,n),O=await i(this,W).call(this,s);o.push({options:s,dataToRemove:u}),o.push({options:O,dataToRemove:v})}const w=[];for(const[u,v]of _.allItems){const O=e.dataOptions[u];if(n[u]&&O&&O.override){if(v.flags.requiresPlus&&!t)continue;const oe=await i(this,q).call(this,u,O,s,e.extension.originMode);w.push(oe);for(const ce of o)ce.dataToRemove[u]=!1}}o.push(...w);for(const u of o)for(const v of Object.keys(u.dataToRemove))u.dataToRemove[v]||delete u.dataToRemove[v];return o});a(this,A,async(e,t)=>{var s,n,o;if(t===f.ActiveTab)return i(this,F).call(this,e);if(e.origins&&(e.origins=await i(this,L).call(this,e.origins)),e.excludeOrigins&&(e.excludeOrigins=await i(this,L).call(this,e.excludeOrigins)),(t!==f.Include||!((s=e.origins)!=null&&s.length))&&delete e.origins,(t!==f.Exclude||!((n=e.excludeOrigins)!=null&&n.length))&&delete e.excludeOrigins,t===f.Include&&!((o=e.origins)!=null&&o.length))throw new Error(`No valid origins configured for mode <em>${f.Include}</em>. <br>Please check your settings.`);return e});a(this,$,async e=>{const t={...e};for(const[s,n]of _.allItems){const o=n.flags.supportsOrigins,w=!!t[s];t[n.key]=o&&w}return t});a(this,D,async e=>{const t={...e};for(const[s,n]of _.allItems)t[n.key]=t[s]&&!n.flags.supportsOrigins;return t});a(this,W,async e=>{const t={...e};return delete t.origins,delete t.excludeOrigins,t});a(this,q,async(e,t,s,n)=>{const o={options:structuredClone(t.removalOptions)||{},dataToRemove:{[e]:!0}};return o.options.since=s.since,o.options=await i(this,A).call(this,o.options,t.originMode||n),o});a(this,F,async e=>{const t=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t.length)throw new Error("No active tab found. Aborting to avoid clearing all data.");const s=new URL(t[0].url);return e.originTypes={unprotectedWeb:!0,protectedWeb:!0,extension:!0},e.origins=[s.origin],delete e.excludeOrigins,e});a(this,L,async e=>e.map(t=>{try{if(t!==new URL(t).origin)throw new Error(`Invalid origin: ${t}. Skipping.`);return t}catch(s){return r.warn(`Could not validate origin ${t}`,s==null?void 0:s.message),""}}).filter(t=>t))}}V=new WeakMap,A=new WeakMap,$=new WeakMap,D=new WeakMap,W=new WeakMap,q=new WeakMap,F=new WeakMap,L=new WeakMap;const j=class j{constructor(e){l(this,"config");l(this,"run",async e=>{const t={neededPermissions:[]};if(this.config.extension.reloadOnClear){const s=await this.reload(e);t.neededPermissions.push(...s.neededPermissions)}if(this.config.extension.closeAllWindows){const s=await this.closeAllWindows();t.neededPermissions.push(...s.neededPermissions)}return t});l(this,"reload",async e=>{if(e!==void 0)try{r.debug(`Reloading tab "${e}" using the tabs API...`),await chrome.tabs.reload(e)}catch(t){return r.info("Couldn't reload tab using the tabs API: "+((t==null?void 0:t.message)??t)+" This can happen when trying to reload a tab within a saved group, which is a known issue with Chrome 125+."),this.reloadUsingScript()}else r.warn(`Target tab "${e}" not found (perhaps it was closed). Aborting reload.`);return{neededPermissions:[]}});l(this,"reloadUsingScript",async()=>{if(r.debug("Reloading using the scripting API as a fallback..."),!("scripting"in chrome))return r.warn("Scripting API not available. Permissions will be requested on next reload."),{neededPermissions:["scripting"]};try{const e=await j.getCurrentTab();e&&e.id!==void 0&&(await he.ensure("scripting"),await chrome.scripting.executeScript({target:{tabId:e.id,allFrames:!0},func:()=>window.location.reload()}))}catch(e){r.error("Couldn't reload tab using scripting API:",(e==null?void 0:e.message)??e)}return{neededPermissions:[]}});l(this,"closeAllWindows",async()=>{try{const e=await chrome.windows.getAll();for(const t of e)t.type!=="app"&&await chrome.windows.remove(t.id)}catch(e){r.error("Couldn't close all windows:",(e==null?void 0:e.message)??e)}return{neededPermissions:[]}});this.config=e}};l(j,"getCurrentTab",async()=>{try{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});return e}catch(e){r.error("Couldn't identify the current tab",e)}});let U=j;var z,g,P,b,T,m,p,E,S,K,M,x,C,y,R,I,N,H,G,J,Q,X,Y,Z,B,k;const d=class d{constructor(){a(this,z,new Le);a(this,g,new ge);a(this,P,me.getInstance());a(this,b,pe.getInstance());a(this,T,we.getInstance());a(this,m,be.getInstance());a(this,p,fe.getInstance());a(this,E,!1);a(this,S,[]);l(this,"init",async()=>{i(this,E)||(r.info("Initializing service worker..."),chrome.runtime.onInstalled.addListener(i(this,Z)),chrome.action.onClicked.addListener(i(this,N)),chrome.alarms.onAlarm.addListener(i(this,H)),i(this,g).addEventListener(ye.ImageUpdate,i(this,R)),i(this,m).addEventListener(ae.LoggedIn,i(this,G)),i(this,m).addEventListener(ae.LoggedOut,i(this,J)),i(this,p).addEventListener(ne.SubscriptionValidated,i(this,Q)),i(this,p).addEventListener(ne.SubscriptionInvalidated,i(this,X)),i(this,P).addEventListener(ve.Updated,async()=>{}),i(this,T).addEventListener(Se.ClearCache,i(this,Y)),await i(this,g).preload(Ie.logoImgPath),await i(this,R).call(this),await i(this,B).call(this),await i(this,K).call(this),await i(this,T).init(),r.info(h.green("...service worker initialized")),se(this,E,!0))});a(this,K,async()=>{r.info(h.magenta("Launching background process...")),i(this,y).call(this,d.AlarmUpdateSession),i(this,y).call(this,d.AlarmValidateSubscription);const e=await i(this,b).hasPending(),t=await i(this,b).shouldOpenOptions();e&&!t&&(r.info(h.blue("Running migrations in background...")),await i(this,b).run()),await i(this,m).init(),await i(this,p).init(),await i(this,m).update(),await i(this,p).update(),await i(this,M).call(this),await i(this,x).call(this)});a(this,M,async()=>i(this,C).call(this,d.AlarmUpdateSession,60));a(this,x,async()=>i(this,C).call(this,d.AlarmValidateSubscription,720));a(this,C,async(e,t)=>{let s=await chrome.alarms.get(e);if(!s||s.scheduledTime<Date.now()){const n=t*6e4;r.debug(`▶️ Starting automatic update ${e} (every ${Oe(n)})`),await chrome.alarms.create(e,{periodInMinutes:t}),s=await chrome.alarms.get(e)}r.debug(`⏲️ Update ${e} scheduled for`,new Date(s==null?void 0:s.scheduledTime).toLocaleString())});a(this,y,async e=>{const t=await chrome.alarms.get(e);t&&(r.debug(`⏹️ Stopping scheduled update ${e} at`,new Date(t.scheduledTime).toLocaleString()),await chrome.alarms.clear(e))});a(this,R,async()=>{const e=await i(this,g).getImageData();return chrome.action.setIcon({imageData:e})});a(this,I,async e=>{let t=Ae();try{const s=i(this,p).isSubscribed(),n=await U.getCurrentTab();await i(this,g).reload(!0),i(this,g).animationStyle=s?re.spin:re.fade,i(this,g).startAnimation(void 0,void 0,!0),t=await i(this,P).load(),e&&(t.extension.originMode=f.Include,t.browser.options.origins=[e]),await i(this,z).clear(t,s),i(this,g).finishAnimation(),r.info(h.green("Cache cleared"));const w=await new U(t).run(n==null?void 0:n.id);w.neededPermissions.length>0&&(r.info(h.yellow("Permissions needed to complete actions:"),w.neededPermissions,h.yellow("Will try again on next browser action.")),i(this,S).push(...w.neededPermissions))}catch(s){r.error("Could not clear cache:",s)}return t});a(this,N,async()=>i(this,S).length>0?chrome.permissions.request({permissions:i(this,S)},()=>i(this,I).call(this)):i(this,I).call(this));a(this,H,async e=>{switch(e.name){case d.AlarmUpdateSession:r.debug("🔄️ Updating session"),await i(this,m).update();break;case d.AlarmValidateSubscription:r.debug("🔄️ Updating subscription"),await i(this,m).update(),await i(this,p).update();break}});a(this,G,async e=>{i(this,M).call(this)});a(this,J,async e=>{i(this,y).call(this,d.AlarmUpdateSession)});a(this,Q,async e=>{i(this,x).call(this)});a(this,X,async e=>{i(this,y).call(this,d.AlarmValidateSubscription)});a(this,Y,async e=>{await i(this,I).call(this,e.origin)});a(this,Z,async e=>{r.info(`Extension runtime installed: ${h.green(e.reason)}`);const t=e.previousVersion??"0.0.0.0",s=i(this,k).call(this);switch(e.reason){case chrome.runtime.OnInstalledReason.INSTALL:r.info(`Extension installed (version ${h.green(s)}). Opening options page...`),await chrome.runtime.openOptionsPage();break;case chrome.runtime.OnInstalledReason.UPDATE:t!==s&&(r.info(`Extension updated from ${h.gray(t)} to ${h.green(s)}`),await i(this,b).queueFor(t,s),await i(this,b).hasPending()&&(r.info("Migrations queued. Reloading extension..."),chrome.runtime.reload()));break;case chrome.runtime.OnInstalledReason.CHROME_UPDATE:case chrome.runtime.OnInstalledReason.SHARED_MODULE_UPDATE:}});a(this,B,async()=>{const t=(await chrome.storage.local.get(d.LastLaunchVersionKey))[d.LastLaunchVersionKey],s=i(this,k).call(this),n=!t,o=!n&&t!==s;await chrome.storage.local.set({[d.LastLaunchVersionKey]:s}),n?r.debug(`First launch (version ${s})`):o?r.debug(`Extension updated from ${t} to ${s}`):r.debug(`Extension re-launched (version ${s})`)});a(this,k,()=>chrome.runtime.getManifest().version)}};z=new WeakMap,g=new WeakMap,P=new WeakMap,b=new WeakMap,T=new WeakMap,m=new WeakMap,p=new WeakMap,E=new WeakMap,S=new WeakMap,K=new WeakMap,M=new WeakMap,x=new WeakMap,C=new WeakMap,y=new WeakMap,R=new WeakMap,I=new WeakMap,N=new WeakMap,H=new WeakMap,G=new WeakMap,J=new WeakMap,Q=new WeakMap,X=new WeakMap,Y=new WeakMap,Z=new WeakMap,B=new WeakMap,k=new WeakMap,l(d,"AlarmUpdateSession","backgroundUpdateSession"),l(d,"AlarmValidateSubscription","backgroundValidateSubscription"),l(d,"LastLaunchVersionKey","lastLaunchVersion");let ee=d;const Pe=new ee;Pe.init();
